## 09/02/2026 - Criar serializers de Category, MenuItem, Stock e preparar base da API

### Objetivo do dia
Fiquei um pouco frustrado com a dificuldade que eu tive na semana passada de implementar as tarefas do projeto durante a minha rotina e quis começar essa semana mais firme. Decidi levar a base da API pra frente montando os códigos dos serializers, das viewsets e fazer uma validação para a quantidade do estoque não ser negativa.

### O que implementei
- Criei o arquivo serializers.py
```python
    from rest_framework import serializers
    from menu.models import Category, MenuItem, Stock


    class CategorySerializer(serializers.ModelSerializer):
        class Meta:
            model = Category
            fields = '__all__'


    class MenuItemSerializer(serializers.ModelSerializer):
        class Meta:
            model = MenuItem
            fields = '__all__'


    class StockSerializer(serializers.ModelSerializer):
        class Meta:
            model = Stock
            fields = '__all__'
```

- Criei as viewsets
```python
    from rest_framework import viewsets
    from menu.serializers import CategorySerializer, MenuItemSerializer, StockSerializer
    from menu.models import Category, MenuItem, Stock


    class CategoryViewSet(viewsets.ModelViewSet):
        serializer_class = CategorySerializer
        queryset = Category.objects.all()


    class MenuItemViewSet(viewsets.ModelViewSet):
        serializer_class = MenuItemSerializer
        queryset = MenuItem.objects.all()


    class StockViewSet(viewsets.ModelViewSet):
        serializer_class = StockSerializer
        queryset = Stock.objects.all()
```

- Criei os routers para a API
```python
    router = routers.DefaultRouter()
    router.register('categories', CategoryViewSet)
    router.register('menuitems', MenuItemViewSet)
    router.register('stock', StockViewSet)

    #No urlpatterns:
        path("api/", include(router.urls))
```

- Validação para Stock
```python
    def is_not_negative(value):
        if value < 0:
            raise ValidationError(f"{value} must be zero or a positive number.")
    
    #No model Stock:
        quantity = models.IntegerField(default=0, validators=[MinValueValidator(0)])
```

- Novo campo is_available em MenuItem
```python
    is_available = models.BooleanField(default=True)
```

### Decisões
- **Por que tirei minimum_stock do model Stock?**
    Inicialmente, criei o campo minimum_stock pensando em criar a validação para a quantidade do estoque. Ele serviria justamente para dois objetivos: Evitar estoque negativo e evitar pedidos que contenham mais unidades do que eu tiver em estoque. Porém, vi que ele seria inútil quando comecei a criar um validador para a quantidade. Seria mais uma questão de regra de negócio.

    Para mim e para o meu negócio, especificamente, eu percebo que quando um produto chega a duas unidades, eu corro um risco considerável de ter que cancelar um próximo pedido. A quantidade mínima poderia variar de um item do cardápio para outro por conta da popularidade deles. Um cookie que sai mais vezes deveria ter um estoque mínimo mais alto do que um cookie menos popular. Porém, nunca se sabe. 

    No código, eu definiria que, se a quantidade chegasse a dois - independentemente de qual seja o item - o produto seria pausado (indisponível) no cardápio. Isso é uma regra que criei agora na cabeça para a validação. É baseada no achismo de que é raro alguém pedir mais de duas unidades de um mesmo item do cardápio. Reconheço que o ideal seria fazer uma análise dos dados de pedidos para pensar nesse código de validação.

    No início, o minimum_stock foi pensado para ser um valor diferente para cada MenuItem e para substituir essa quantidade 2 específica que relatei acima. Preferi só fazer isso pela validação ao invés de "gastar" um campo no model.

- **Por que criei um campo novo em MenuItem?:**
    Optei por criar esse campo já pensando em criar uma validação que automatize o controle de pedidos. Inicialmente, ia criar uma função lock_orders() logo em seguida da validação da quantidade de estoque que se basearia na condição de que, quando o estoque atingisse um determinado valor (2 unidades, por exemplo), o item ficaria indisponível automaticamente. Porém, me compliquei nessa função porque ela teria que gerar uma interação entre dois models: MenuItem - pra ficar indisponível - e Stock - para analisar a quantidade. Como achei complicado de cara, preferi deixar para outro dia já que eu já tinha feito bastante coisa.

    Penso que a solução possa estar em um novo serializer - que juntaria MenuItem com Stock. A ver.

### Desafios
1. Apesar de ter optado por uma validação do Django para a quantidade do estoque, quando fui excluir a função para validação que eu mesmo criei (is_not_negative) aparecia esse erro: 
![Erro no Console](prints/image3.png)
   - **Como resolvi:** Pedi para um chatbot de inteligência artificial (gemini) me ajudar a interpretar a mensagem de erro e cheguei na solução de excluir a função no arquivo gerado pelo Django nas migrations (0006_menuitem_is_available_alter_stock_quantity.py) e colocar MinValueValidator no lugar. Código abaixo:
   ```python
        from django.core.validators import MinValueValidator
        from django.db import migrations, models


        class Migration(migrations.Migration):

            dependencies = [
                ('menu', '0005_alter_menuitem_image'),
            ]

            operations = [
                migrations.AddField(
                    model_name='menuitem',
                    name='is_available',
                    field=models.BooleanField(default=True),
                ),
                migrations.AlterField(
                    model_name='stock',
                    name='quantity',
                    field=models.IntegerField(default=0, validators=[MinValueValidator(0)]),
                ),
            ]
   ```
   - **O que aprendi:** Eu tinha feito as migrations iniciais com essa função antes de colocar o MinValueValidator. O Django manteve a função is_not_negative que eu tinha criado registrado nas migrations e, como elas funcionam como um diário, acabou exigindo que eu não excluísse.

2. Onde colocar routers?
   - **Como resolvi:** Estava entre colocar a configuração de DefaultRouter no arquivo urls.py do app e no arquivo urls.py do setup. Parei para pensar um pouco depois de ler a documentação.
   - **O que aprendi:** Interpretei as informações do código que eu estava montando como sendo específicos do app menu. Utilizando serializers do item do cardápio, de categorias e de estoque, achei mais específico do app do que com o projeto como um todo.

3. Onde colocar a validação do estoque? No model ou no serializer? Nos dois?
   - **Como resolvi:** Preferi colocar a validação no model.
   - **O que aprendi:** Como o model é o nível mais inicial dos dados, faz mais sentido colocar a validação logo no começo para não ter erros durante os diversos processos que podem surgir a partir deles.


### Referências
- https://www.django-rest-framework.org/
- https://www.django-rest-framework.org/api-guide/serializers/#modelserializer
- https://www.django-rest-framework.org/api-guide/viewsets/
- https://www.django-rest-framework.org/api-guide/routers/
- https://docs.djangoproject.com/en/6.0/ref/models/fields/#booleanfield
- https://docs.djangoproject.com/en/6.0/ref/validators/#minlengthvalidator

### Próximos passos
- [ ] Como fazer validação para o estoque mínimo - seria uma validação ou outra coisa?
- [ ] Fazer serializer para MenuItem por Categoria ("MenuItemByCategory")

---