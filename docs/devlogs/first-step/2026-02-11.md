## 11/02/2026 - Fazer um nested serializer para o cardápio

### Objetivo do dia
Criar um serializer MenuItemByCategory para listar todos os produtos de cada categoria. No final, os dados - em formato JSON - estariam praticamente iguais a um cardápio: Separado por categorias e seus respectivos itens.

### O que implementei
- MenuItemByCategorySerializer
```python
    class MenuItemByCategorySerializer(serializers.ModelSerializer):
        menu_items = MenuItemSerializer(many=True, read_only=True, source="menuitem_set")

        class Meta:
            model = Category
            fields = ["id", "name", "menu_items"]
```
- Generic ListAPIView
```python
    class MenuItemByCategoryViewSet(generics.ListAPIView):
        serializer_class = MenuItemByCategorySerializer
        queryset = Category.objects.prefetch_related("menuitem_set").all()
```
- Path para View
```python
    path("api/item-by-category/", MenuItemByCategoryViewSet.as_view(), name="item-by-category")
```

### Decisões
- **Como fiz o Serializer:**
  Durante meus estudos iniciais, há um tempo atrás, eu tinha visto várias maneiras de montar nested serializers e sempre fiquei meio perdido. Talvez realmente tenham vários meios para montar esses serializers, mas isso foi um problema muito grande montando agora, na prática e sozinho. Quando fui pegar o código, não sabia nem por onde começar já que tinham tantas possibilidades. Acabei priorizando uma forma mais simples.

  Dando um passo para trás, parei para pensar: O que eu quero com esse serializer aninhado? Para que ele serviria?

  Depois de algumas pesquisas e algumas perguntas com o Gemini, cheguei a conclusão de que ele serviria como a base para o cardápio final. O resultado final - os dados JSON - ficou até muito semelhante com o cardápio em si. A categoria, com seus respectivos produtos, seguida de outras categorias com seus produtos. Isso facilita a vida do frontend e torna o website final mais leve, já que não exigiria tanta lógica em javascript pelo frontend, por exemplo, para montar o cardápio. Os dados já viriam no formato ideal.

  Parâmetros:
    many=True: Baseado no relacionamento "to-many", que serviria para categorias e produtos. Como cada categoria pode ter vários produtos, ela deveria receber uma lista, não 1 produto.

    read_only=True: Autoexplicativo. São informações apenas para leitura. Qualquer modificação será feita nos models originais.

    source=menuitem_set: Algo novo com o que eu tive certa dificuldade. 'source', por si só, é autoexplicativo. Preciso de uma fonte de onde tirar os dados. Porém, 'menuitem_set' foi algo que me complicou a vida, já que é um nome definido pelo próprio Django para os objetos de MenuItem.

### Desafios
1. Path ou Router para a view de item-by-category
   - **Como resolvi:** Depois de montar a viewset, fui para urls.py fazer as configurações de rota e me deparei com um erro ao rodar o servidor: AttributeError: type object 'MenuItemByCategoryViewSet' has no attribute 'get_extra_actions'. Pesquisei um pouco mas preferi mandar o erro para o Google Gemini.
   - **O que aprendi:** Generics são diferentes de ViewSets. Enquanto uma precisa das rotas, a outra é melhor configurada como path, por ter menos funcionalidades.

2. Prefetch Related
   - **Como resolvi:** Tive que conversar muito com o Gemini para entender isso direito. Documentação serviu pouco.
   - **O que aprendi:** Primeiro, tive que entender qual seria a ordem de processamento. Qual seria o fluxo dos dados. Apesar de ter montado na ordem Serializer > Viewset > Urlpatterns, os dados fluem na direção inversa. Começa com uma requisição e o path, em urlpatterns, que funciona como um porteiro, que permite a entrada do usuário no projeto. Depois, roda o código da viewset, ou seja, o prefetch_related acontece antes do processamento das informações do serializer.

   Pelo nome, já tinha entendido o que o prefetch faz. Ele evita que o Django "vá e volte" várias vezes no banco de dados ou, simplesmente, que faça muitas consultas e gaste processamento, evitando o problema de consultas N+1. Porém, ainda não tava muito claro quanto à ordem dos acontecimentos, porque eu estava pensando na ordem em que eu montei o código.

   Com todos os objetos do model MenuItem relacionados com Category já selecionados previamente, entra o próximo passo do processamento: O serializer. Como ele funciona como tradutor, pega o queryset de MenuItem relacionados com Category e transforma em JSON. Como o set já foi selecionado pela view, não precisa consultar de novo.

### Referências
- https://www.django-rest-framework.org/api-guide/serializers/#modelserializer
- https://www.django-rest-framework.org/api-guide/fields/#readonlyfield
- https://www.django-rest-framework.org/api-guide/relations/#nested-relationships
- https://www.django-rest-framework.org/api-guide/fields/#serializermethodfield
- https://docs.djangoproject.com/en/6.0/ref/urls/#kwargs
- https://stackoverflow.com/questions/5255913/kwargs-in-django
- https://docs.python.org/2/tutorial/controlflow.html#keyword-arguments
- https://stackoverflow.com/questions/2642613/what-is-related-name-used-for
- https://docs.djangoproject.com/en/6.0/ref/models/querysets/#prefetch-related

---