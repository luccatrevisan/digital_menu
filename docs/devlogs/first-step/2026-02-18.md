## 18/02/2026 - Feature de preço promocional e validação

### Objetivo do dia
Primeiro dia voltando do carnaval, tava bem descansado e motivado. Já tinha pensado anteriormente em fazer algumas mudanças no model de MenuItem para poder implementar preços promocionais. Alguns itens, todos da categoria de "Ofertas da Chewie", por exemplo, têm um preço original - mais caro - e um preço promocional, atualizado - mais barato. O objetivo era criar um old_price que poderia ser opcional (null e blank) e uma validação para evitar preços antigos mais baratos que o preço atualizado.

### O que implementei
- Atributos price e old_price
```python
    class MenuItem(models.Model):
        price = models.DecimalField(max_digits=10, decimal_places=2, null=False, blank=False) # optei por deixar price como o preço original
        old_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True) # caso o item tivesse preço promocional, usaria o old_price
```
- Validações
```python
    class MenuItem(models.Model):
        def clean(self): # aprendi muito sobre o método clean nesse código
            if self.old_price is not None and self.old_price <= self.price:
                raise ValidationError("Invalid price.")

        def save(self, *args, **kwargs):
            self.full_clean()
            super().save(*args, **kwargs)
```
- Configurações no Admin
```python
    class MenuItemAdmin(admin.ModelAdmin):
        list_display_links = ["id", "name"] # adicionei links para as informações da instância no nome para ser mais intuitivo
        ordering = ["id"] # ordenei o admin por ID (ordem de criação)
```

### Decisões
- **Por que escolhi fazer a validação dentro do model e utilizando clean() e save():**
    Qualquer tentativa de salvar o objeto passará a validação. Considerando que o dado pode ser inserido no banco através do shell, do admin ou da API, por exemplo, ele sempre se baseia no model. Isso garante que o dado estará limpo. Se eu faço a validação no Serializer, conseguiria um dado limpo somente criando pela API.

    Ainda tem a questão de envolver dois campos de MenuItem. Ao criar uma validação entre old_price e price, eu precisaria de um método que permitisse acesso ao "self", tendo as informações de múltiplos atributos. Caso fosse uma validação de só garantir que price seja positivo, poderia utilizar menos linhas chamando o atributo "validators=" dentro do campo de price.

    Durante minhas pesquisas, descobri que clean não funciona por si próprio. Por isso a utilização do método save.

### Desafios
1. Tive certa dificuldade em entender a função save (do próprio Django) e, principalmente, os seus argumentos *args e **kwargs
   - **Como resolvi:** Pesquisei nas documentações o que seriam os asteriscos e o que esses argumentos significam.
   - **O que aprendi:** Literalmente, vejo que args significa arguments e, kwargs, keyword arguments. Porém, queria saber mais sobre o que eles significam na técnica. Aprendi que, em resumo, são argumentos que o Django passaria para garantir o funcionamento correto da função. Em uma atualização, por exemplo, eles poderiam adicionar um argumento à função save() e ela receberia esse argumento novo. Os asteriscos são para marcar justamente isso e por não serem variáveis declaradas anteiormente no código.

### Referências
- https://docs.djangoproject.com/en/6.0/ref/contrib/admin/
- https://docs.djangoproject.com/en/6.0/ref/contrib/admin/#django.contrib.admin.ModelAdmin.ordering
- https://docs.djangoproject.com/en/6.0/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list_display_links
- https://docs.djangoproject.com/en/6.0/ref/forms/validation/
    "The clean() method on a Field subclass is responsible for running to_python(), validate(), and run_validators() in the correct order and propagating their errors. If, at any time, any of the methods raise ValidationError, the validation stops and that error is raised. This method returns the clean data, which is then inserted into the cleaned_data dictionary of the form."

- https://docs.djangoproject.com/en/6.0/ref/validators/
- https://docs.djangoproject.com/en/6.0/ref/models/instances/
- https://docs.djangoproject.com/en/6.0/ref/models/instances/#saving-objects
- https://docs.djangoproject.com/en/6.0/topics/db/models/#overriding-model-methods
    "if you forget to call the superclass method, the default behavior won’t happen and the database won’t get touched."

- https://stackoverflow.com/questions/22587019/how-to-use-full-clean-for-data-validation-before-saving-in-django-1-5-graceful

---