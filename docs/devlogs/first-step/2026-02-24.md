## 24/02/2026 - Models Complement e ComplementGroup

### Objetivo do dia
Antes de montar o serializer aninhado com o estoque de cada item, preferi seguir com a base da funcionalidade de complementos. Criar dois models: Complement e ComplementGroup. Assim como um item do menu está para uma categoria, um complemento está para um grupo de complementos. É uma parte do grupo.

### O que implementei
- Model Complement
```python
class Complement(models.Model):
    name = models.CharField(max_length=100, blank=False, null=False)
    price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    description = models.TextField(max_length=300, blank=True, null=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return self.name
```
- Model ComplementGroup
```python
class ComplementGroup(models.Model):
    menu_item = models.ForeignKey(MenuItem, on_delete=models.CASCADE)
    name = models.CharField(max_length=100, blank=False, null=False)
    min_quantity = models.IntegerField(blank=False, null=False, validators=[MinValueValidator(0)])
    max_quantity = models.IntegerField(blank=False, null=False)
    complements = models.ManyToManyField(Complement)

    def __str__(self):
        return self.name
```
- min_quantity e max_quantity validation:
```python
class ComplementGroup(models.Model):
    def clean(self):
        if self.min_quantity > self.max_quantity:
            raise ValidationError("The minimum quantity must be less than the maximum.")
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
```
- admin register
```python
class ComplementAdmin(admin.ModelAdmin):
    list_display = ["id", "name", "price"]
    list_display_links = ["id", "name"]
    search_fields = ["name"]
    ordering = ["id"]

admin.site.register(Complement, ComplementAdmin)


class ComplementGroupAdmin(admin.ModelAdmin):
    list_display = ["id", "name", "menu_item", "min_quantity", "max_quantity"]
    list_display_links = ["id", "name"]
    search_fields = ["name", "menu_item"]
    ordering = ["id"]

admin.site.register(ComplementGroup, ComplementGroupAdmin)
```

### Decisões
- **Por que quantidade mínima deve apenas ser menor que quantidade máxima?**
    Originalmente, estava considerando que quantidade mínima não poderia ser nem igual à quantidade máxima porque, nos sistemas de cardápios que eu utilizo, eu coloquei quantidade mínima = 1 nos itens obrigatórios e a quantidade máxima de acordo com o item do cardápio. Porém, lembrei depois que já aconteceram casos em que algum cliente não escolheu todos os itens necessários e eu perdi um tempo mandando mensagem avisando. 

    Apesar de ser uma prática minha, percebi que estava errado e devo até mudar as configurações desses itens no cardápios que ainda utilizo. Depois de analisar melhor, preferi optar pelo código abaixo:

```python
    if self.min_quantity > self.max_quantity:
            raise ValidationError("The minimum quantity must be less than the maximum.")
```
    Assim, o restaurante pode obrigar a pessoa a escolher o que é necessário sem ter retrabalho.

- **Por que escolher fazer a validação de quantidade mínima e máxima em outro momento?**
    Porque eu precisaria do sistema de carrinho/sacola para concluir essa lógica de validação completamente. Parei para pensar mais na experiência do cliente para poder chegar em uma conclusão antes de pensar em código. Suponha que o cliente esteja usando o cardápio, escolhendo os itens dele, quando ele se depara com um combo que tem complementos obrigatórios - como realmente tem no meu cardápio. Se ele não escolher tudo que precisa e a validação de quantidade mínima do ComplementGroup desse produto acontecer só no final do processo, quando ele estiver pronto para pagar, pode acabar gerando uma frustração e ele acabar desistindo da compra. É preciso que essa validação aconteça cedo.

    Se a validação acontece ao ele clicar "Adicionar ao carrinho" nesse mesmo item, ele não conseguirá e receberia um aviso mandando ele escolher tudo que precisa. Desse jeito, a mudança é mais simples. A solução, para ele, é mais simples do que voltar alguns passos do funil (de vendas) para conseguir pagar e fechar o pedido. Por isso, é mais interessante esperar adicionar a feature de carrinho.

    Porém, isso não significa que o fechamento do pedido não deva ter qualquer validação de quantidades mínimas. Pode ser que eu adicione um pedido mínimo geral também, não só quantidades mínimas por item.

### Desafios
1. Nesse dia, tive mais problemas com a parte teórica do que com código. Travei na hora de pensar em como organizar esses models.
   - **Como resolvi:** Como já comentei anteriormente, vejo que tenho certa dificuldade na hora de pensar em relacionamentos e entidades para montar a estrutura do banco de dados apesar de estar mais familiarizado com algumas práticas por conta do projeto. 
   - **O que aprendi:** Com certeza eu deveria fazer uma estrutura mais visual do banco de dados. Posso estar pecando em alguns pontos por não conseguir visualizar bem como o projeto está estruturado. Porém, a cada semana eu adiciono algo novo ou penso em uma feature que exigiria um model novo. Fica a dúvida: é comum planejar o banco de dados visualmente e mudar ele com frequência?

### Referências
- https://docs.djangoproject.com/en/6.0/ref/models/fields/#booleanfield
- https://docs.djangoproject.com/en/6.0/topics/db/examples/many_to_many/

### Próximos passos
- [ ] criar serializer aninhado com categoria > menu_item > estoques > complementos
- [ ] criar normalizações de entradas no model (.title(), .capitalize() etc)

---